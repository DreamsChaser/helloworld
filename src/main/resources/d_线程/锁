并发下的线程安全
锁、同步、原子类、volatile

锁：
悲观锁（例如：synchronized）: 默认每次修改数据都有冲突
乐观锁（列入: reentrantLock）: 默认每次没有冲突，修改数据时才会检验
悲观锁在Java中的使用，就是利用各种锁。观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类


公平锁：指多个线程按照申请锁的顺序来获取锁。
非公平锁（synchronized，reentrantLock默认是，可以设置）：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，
非公平锁效率好（吞吐量高）

分段锁：列入1.7的currenthashmap

可重入锁（递归锁）：线程可以进入任何一个它已经拥有的锁所同步着的代码块
lockBy：保存已经获得锁实例的线程，在lock()判断调用lock的线程是否已经获得当前锁实例，如果已经获得锁，则直接跳过while，无需等待。
不可重入锁：当一个线程获得了当前实例的锁，并进入方法A，这个线程在没有释放这把锁的时候，不可以再次进入方法A
自旋锁：非阻塞不停的循环判断锁的状态，一旦别的线程释放锁，则立刻得到锁，要求持有锁时间段



偏向锁/轻量级锁/重量级锁（指的锁的状态）
锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁
偏向锁
同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。

synchronized同步原理:
每个对象有一个监视器锁（monitor）
线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者
如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

执行monitorexit
指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。


