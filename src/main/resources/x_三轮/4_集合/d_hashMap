1、底层实现
底层是数组+单链表+红黑树
数组
Node[] table哈希桶数组
链表节点(键值对)
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash; //用来定位数组索引位置
        final K key;
        V value;
        Node<K,V> next; 下一个节点
}
int threshold;所能容纳的key-value对极限 threshold = length(node数组长度) * Load factor 超过这个数目就重新resize
final float loadFactor;    // 负载因子默认0.75
int modCount; 而modCount字段主要用来记录HashMap内部结构发生变化的次数(key不变value变则不属于结构变化)
int size; HashMap中实际存在的键值对数量

//扰动函数，确定key所在的位置
右移16位然后异或
key的hashCode值返回int型是个-2^31 2^31的，一般情况下很少发生碰撞，对数组长度取模，h&(length-1) 长度选2次幂这样是个低位掩码，
每次取后几位，但这样碰撞会很严重
int32bit 右移16位 高8位低8位异或 保证hash碰撞次数少
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}


2、添加元素
put
a、Node[]数组为空或者长度为0 => esize扩容
b、计算key的hash和数组下标i = (n - 1) & hash 若该数组下标上的值为null则新建Node，newNode(hash, key, value, null)，否则往下
c、若该数组下标上的值不为空则判断该位置上的Node和put的Node做比较(hash==,key==||key.equals)一直则覆盖,否则向下
d、原位置Node与put的Node不一致则遍历链表若(hash==,key==||key.equals)则覆盖，否则遍历结束后再最后new Node （长度大于8则转化为红黑树）
e、判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

3、扩容方式

4、优缺点

5、线程安全性
非线程安全

6、其它特性
键和值都可以为空（建为空是k=0）