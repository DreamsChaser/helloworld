一、单例模式（对象的创建模式）：保证一个类只有一个实例，并提供一个访问他的全局访问点
1、懒汉式(使用时才加载)
2、饿汉式(初始化时就创建了)
3、双检锁/双重校验锁(这种方式采用双锁机制，安全且在多线程情况下能保持高性能)
4、登记式/静态内部类
5、枚举
   枚举单例的好处(其他单例通过反射或者序列化反序列化不能保证单例)

二、工厂模式（对象的创建模式）：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
主要解决：主要解决接口选择的问题。

简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）
工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）
抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）

三、原型模式（对象的创建模式）
一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象(列入clone)

四、策略模式
针对一组算法，将每一个算法封装到具有共同接口的独立类中，从而使得它们可以相互替换。

五、适配器模式
可以把一个类的接口变换成客户端所期待的另一种接口，使得原本因接口不匹配而无法在一起工作的两个类可以一起工作。

六、迭代器模式
是提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节

七、代理模式
静态代理 动态代理

八、观察者模式
让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。
列（kafka）

九、外观模式
外部与一个子系统的通信必须通过一个统一的外观对象进行

十、装饰器模式、包装（Wrapper）模式
装饰器模式以多客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。