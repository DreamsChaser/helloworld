-------------------------------
一、java内存结构
1、线程共享区:
    a.堆：存放所有对象(数组也是对象)（1.7以后字符串常量池也在这之前在方法区中）
    b.方法区(hot spot中的实现为元空间(原叫永久带))：存放编译后的class信息包括类变量和常量(运行时常量池在方法区中)
2、线程私有区:
    a.栈:每个方法会创建一个栈帧push进栈在方法结束后pop出去(局部变量表,对象的引用，方法返回值)
    b.本地方法栈:为native方法服务
    c.程序计数器: 记录当前线程的内存地址
----------------------------------------------------------------------------------
二、类加载机制
1、java中的类加载是双亲委派机制。每次加载一个类都会交给父加载器去加载，父加载器找不到该类时才会让子加载器加载
一共有四类加载器。分别是
a、启动类加载器bootstrap classloader，加载jre/lib
b、扩展类加载器extension classloader，加载jre/lib/ext
c、应用程序启动类加载器application classloader，加载classpath下的类
d、自定义加载器，根据自定义规则加载指定的类,见../../cn.com.git.leon.classLoader.CustomerClassLoader.java

2、类加载的过程
A 加载:通过一个类的完全限定查找此类字节码文件,把class信息加载到方法区，并在堆中实例化一个java.lang.Class对象
B 连接
    a 验证
        验证字节码文件(文件格式验证，元数据验证，字节码验证，符号引用验证)
    b 准备
        为类变量static分配存储空间并置上初始值，final修饰的类变量在编译阶段赋值(见../2java core)
    c 解析
        符号引用替换为直接引用,jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。
C 初始化
    (创建类的实例、访问某个类或接口的静态变量(final定义的除外)，或者对该静态 变量赋值、调用类的静态方法
    反射（如 Class.forName()、初始化一个类的子类、Java虚拟机启动时被标明为启动类的类（Java Test）)
    读取或设置类的静态变量、调用类的静态方法、调用静态代码块。
    例如 ClassLoader.loadClass和Class.forName前者不会初始化，后者会。

3、类加载过程中各个方法的执行顺序 见../../三轮/A_java虚拟机及类加载
先父后子，先静后常再构造
同等级内代码逐条按顺序执行
* 当静态代码和非静态代码中成员变量包含对象，也会先执行该对象类的静态代码和构造函数
